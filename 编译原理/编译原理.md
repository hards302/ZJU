## 编译原理

> 2022/02/21 记录大三下学期课程——编译原理。老师：fy，ch。

### Ch1 introduction

<img src="C:\Users\MHTzt\AppData\Roaming\Typora\typora-user-images\image-20220221210818964.png" alt="image-20220221210818964" style="zoom:50%;" />

这张图展示了编译器将source code转换为target code的过程。其中的细节会在之后一一讲到。

#### bootstrapping and porting

- T-diagram

  <img src="C:\Users\MHTzt\AppData\Roaming\Typora\typora-user-images\image-20220221211307842.png" alt="image-20220221211307842" style="zoom:50%;" />这张图表示用H语言写的编译器将S语言转换为T语言。

- Bootstarp process

  <img src="C:\Users\MHTzt\AppData\Roaming\Typora\typora-user-images\image-20220221211755721.png" alt="image-20220221211755721" style="zoom:50%;" />使用基于H语言的编译器将A转换为H看起来不太靠谱，所以进行这样一次bootstarp process让H变的靠谱一些，至少可以运行。再进行这样一次变换，就可以形成基于H语言的编译器的比较可靠的版本。

- Porting

  <img src="C:\Users\MHTzt\AppData\Roaming\Typora\typora-user-images\image-20220221212145662.png" alt="image-20220221212145662" style="zoom:50%;" />使用左上的源代码重定向编译器和右下的交叉编译器可以做成目标代码重定向编译器。

### Ch2 Scanning(lexical analysis)

> 词法分析，将源码变成token。

- scanning process

  将token分类，分为整数类型，浮点数类型，字符串类型，注释，自定义，关键词(if, else, for…)，符号(+,*)

- 正则表达式

  按照最长匹配的规则进行匹配。
  
  lookahead原则：每次检查时都多向前检查一位，若下一位与此位属于一个token则一起处理，否则视为下一个关键词。
  
- 有限自动机

  有限自动机（DFA/NFA）的知识在计算理论课程中学过了，不细讲。

  我们认为，可以用DFA来模拟一个正则表达式，对于一个输入，可以判断它是否满足那个正则表达式。

  一般而言我们会更直接地使用NFA来模拟，此时我们需要将NFA转换为DFA。这也是计算理论的知识：只需要将NFA中空串闭合的状态集合视为DFA中的一个特定集合即可。

- transtition table

  当我们使用DFA来模拟正则表达式时，为了统一自动机的代码实现，我们使用转换表来表示当处于状态t并接受输入a时会转变到何种状态。
  
- 构造一个扫描程序的自动过程可以分为3步，从正则表达式–>NFA–>DFA–>程序。

  1. 从正则表达式到NFA：

     **Thompson结构**：将正则表达式的几种方式用基本NFA模拟后结合起来。

     1. 基本正则表达式：

        <img src="C:\Users\MHTzt\AppData\Roaming\Typora\typora-user-images\image-20220319190600200.png" alt="image-20220319190600200" style="zoom:50%;" />

     2. 并置：

        <img src="C:\Users\MHTzt\AppData\Roaming\Typora\typora-user-images\image-20220319190626940.png" alt="image-20220319190626940" style="zoom:50%;" />

        有时候可以省略中间的e，但是如果还有其他状态混合的话，就不可以直接省略e了。

     3. 选择：

        <img src="C:\Users\MHTzt\AppData\Roaming\Typora\typora-user-images\image-20220319190838892.png" alt="image-20220319190838892" style="zoom:50%;" />

     4. 重复：

        <img src="C:\Users\MHTzt\AppData\Roaming\Typora\typora-user-images\image-20220319191555420.png" alt="image-20220319191555420" style="zoom:50%;" />

        eg.

        <img src="C:\Users\MHTzt\AppData\Roaming\Typora\typora-user-images\image-20220319191719720.png" alt="image-20220319191719720" style="zoom:50%;" />

  2. NFA–>DFA:

     将所有通过e转换的状态集合在一起。

  3. 最小化DFA：

     自动机理论中有一个很重要的结论，即对于任意一个DFA，都有一个含有最少量状态的等价DFA，且这个DFA是唯一的。

     这里我们介绍一个概念：

     不可区分状态：即对于一个DFA转换中的两个状态，它们两个接受相同的输入，并且对同一个输入做相同的输出，此时我们认为这两个状态是不可区分的。

     最小化DFA就是将所有状态中的不可区分状态找出来并且合成一个状态，这就是最小化的DFA。
     
     > 这里介绍一个技巧：先把所有可以变为空串的变空，得到这个表达式的最小串，然后用DFA可以很容易地表达出这个最小串（直接按顺序连接起来就行），然后再将有‘*’的表达式添加到这个DFA中，只需要遵守一个规则：不要出现一个状态相同输出连接到不同的次状态即可。

### Ch3 Context-Free Grammars and Parsing

> 将分解的token按一定的规则组合成有意义的句子。

- 在parsing过程中，一般遇到error时进行报告，然后跳过继续检查。

- CFG的知识点在计算理论学过，不细讲。

- Parse Trees

  <img src="C:\Users\MHTzt\AppData\Roaming\Typora\typora-user-images\image-20220307165633169.png" alt="image-20220307165633169" style="zoom:50%;" />

- leftmost/rightmost derivation（BNF范式）

  <img src="C:\Users\MHTzt\AppData\Roaming\Typora\typora-user-images\image-20220307165721876.png" alt="image-20220307165721876" style="zoom:50%;" />

- Abstract syntax trees

  一种更简单的表示方式。可以将op放在上一层，下一层放操作数。

- Ambiguity

  有时，CFG是不明确的，导致有两种不同形式的parse trees，会产生歧义，比如计算式的顺序（需要添加小括号），if和else的匹配（需要添加大括号）等。有两种解决方式：

  可以选定一种。但是这样很僵硬。

  也可以改变grammar的生成形式。

  **判断是否ambiguous的方式**：是否有多个parse trees或者多个最左（最右）推导（而不是有多个推导就行了）。

- EBNF范式

  EBNF范式在BNF范式上添加了花括号和方括号标记，用花括号{…}来表示重复，用方括号[…]来表示可选。

### Ch4 Top to buttom 自顶向下的分析

> 自顶向下分析即，给定一个terminal串（一堆token），将其恢复成parse tree。
>
> 本章主要学习两种自顶向下的分析算法，分别是递归下降分析和LL(1)分析。
>
> 递归下降分析很常用，对于手写的分析程序最合适。
>
> LL(1)分析实际中并不常用，但是是更强大复杂的自底向上算法的前篇。

- 递归下降分析算法

  该算法的基本思想即：将一个非终结符A的文法规则看作识别A的一个过程。

  在这里，文法规则我们一般使用EBNF。可以消解一部分BNF的二义性。

  但是该算法有一定的问题。首先，BNF转换为EBNF格式可能会有困难。其次，在用公式表达一个或选择$A\rightarrow \alpha | \beta$时，如果α和β都以非终结符开始，那么很难决定选择哪个。（此时，需要计算α和β的First集合）。再次，在写e产生式的代码$A \rightarrow e$时，需要了解什么记号可以正规地出现在非终结符A之后，然后替换掉A，使非终结符A消失。（这个集合就是Follow集合）。

- LL(1)分析算法

  > LL(1)算法的第一个L指的是从左向右进行处理。第二个L指的是它为输入串描绘出一个最左推导。括号中的1表示它仅使用输入中的一个符号来预测分析的方向。

  LL(1)分析使用显示栈而不是递归调用来完成分析。栈底放置一个符号‘$’，用来表示栈空。然后在开始时压入一个起始符S。然后将输入从右到左压入栈（为了从左到右进行左替换）。

  可以通过构造**LL(1)分析表**来表达可能的选择。用M[N,T]表示，N即非终结符，T即终结符。而构造该矩阵的规则有两条：

  1. 在输入中检测到a，而α可以匹配生成一个a，且存在$A \rightarrow \alpha$，则希望挑选该规则。（First集合的来源）。
  2. 在输入中检测到a，若$A \rightarrow \alpha$派生了空串，而a是可以合法出现在A之后的，则希望挑选该规则。（Follow集合的来源）。

  **定义：** 如果文法G相关的LL(1)分析表的每一项中至多只有一个产生式，则该文法就是LL(1)文法。

  该定义暗示着利用LL(1)文法表就能构造出一个无二义性的分析，所以LL(1)文法不能是二义的。

  - 左递归消除和左因子提取

    LL(1)分析中的重复和选择也存在，但是由于直接使用BNF，所以我们采取左递归消除和左因子提取的技术。

    $A\rightarrow A\alpha | \beta$转换成：$A\rightarrow \beta A’\\A’\rightarrow \alpha A’ | e$。

    $A\rightarrow A\alpha_1|A\alpha_2|…|A\alpha_n|\beta_1|\beta_2|…$转换成：$A\rightarrow\beta_1A’|\beta_2A’|…\beta_mA’\\A'\rightarrow \alpha_1A'|\alpha_2A'|...|\alpha_nA'|e$。
  
    $A\rightarrow \alpha \beta | \alpha \gamma$转换成$A\rightarrow \alpha A'\\A'\rightarrow(\beta|\gamma)$。
  
  - First集合和Follow集合

    **First集合：**令X为一个文法符号。First(X)的定义如下：

    1. 若X是终结符或e，则First(X)={X}。
    2. 若X是非终结符，则对于$X\rightarrow X_1X_2…X_n$,First(X)是First(X_i)-{e}的合集。若所有First(X_i)都包含了e，则First(X)也包含e。

    > 可以看出，First(X)其实就是X可以生成的所有第一个非终结符。

    **Follow集合：**给出一个非终结符A，则Follow(A)是由终结符组成。此外可能还有‘$’。定义如下：

    1. 若A是开始符号，则$在Follow(A)中。
    2. 若存在$B\rightarrow \alpha A \gamma$, 则First(γ)-{e}在Follow(A)中。
    3. 若存在$B\rightarrow \alpha A \gamma$, 且e在First(γ)中，则Follow(B)在Follow(A)中。

  此时我们可以重新构造一次LL(1)分析表。

  1. 对于First(α)中的每个记号a，都将$A\rightarrow \alpha$添加到M[A,a]中。
  2. 若e在First(α)中，则对Follow(A)的每个元素a(记号或是‘\$’)，都将$A\rightarrow a$添加到M[A,a]中。

  **定理：**若满足以下条件，则BNF中的文法就是LL(1)文法。

    1. 在每个产生式$A\rightarrow \alpha_1|\alpha_2|…|\alpha_n$中，对于所有的i和j,$1\le i,j \le n, i \not = j, First(a_i)\and First(a_j)=e$。
    2. 若对于每个非终结符A都有$e \in First(A)$, 则$First(A) \and Follow(A) = e$.

- 自顶向下分析程序中的错误校正

  标准形式叫做应急方式（panic mode）。在分析处理时，作为同步记号的记号在每个调用发生时被添加到这个集合中。如果遇到错误，分析程序就会向前扫描（scan ahead），并一直丢弃记号直到看到输入中记号的一个同步集合为止，并从这里恢复分析。在做这种扫描时，通过不生成新的出错信息来在某种程度上避免错误级联。

  Follow集合是这样的同步记号中重要的一员，Follow集合也可用来使错误处理器避免跳过开始新的主要结构的重要记号（如语句或表达式）。First集合也很重要，因为它允许递归下降程序能在分析的早些时候检测出错误，这对于任何错误校正程序总是有用的。

### Ch5 Buttom to Top 自底向上的分析

自底向上的分析程序有两种可能的动作：

1. 将终结符从输入的开头移到栈顶（shift）
2. 假设有BNF存在A->α，将栈顶的α替换为A（reduce）

自底向上的分析程序还有个特点，就是扩充一个新的起始符S‘，如果令原来的起始符S，则存在S’->S。

对于：$S’ \rightarrow S\\ S\rightarrow (S) S | e$，有如下分析过程：

<img src="C:\Users\MHTzt\AppData\Roaming\Typora\typora-user-images\image-20220321165032115.png" alt="image-20220321165032115" style="zoom:50%;" />

- LR(0)项的有穷自动机与LR(0)分析

  - LR(0)项目：

    上下文无关文法的LR(0)项是在它右边带有区分位置的产生式选择。我们用一个句点’.’表示这个区分的位置。如上述例子存在8个项目：S’->.S, S’->S., S->.(S)S, S->(.S)S, …, S->.

    > 其实这个‘.’就是表示识别到哪里了。

    项目概念的思想就是指项目记录了特定文法规则右边识别中的中间步骤。

    比如，A->b.y，这一点意味着我们已经看到了b（在栈顶），且可能从下一个输入中获取到y。

    而A->.a，意味着将要利用文法规则选择A->a识别A。（初始项）

    而A->a.，意味着a现在位于分析栈的顶部，而且若A->a在下一个规约中使用的话，它有可能就是句柄。（完整项）

  - LR(0)有穷自动机：

    我们先从NFA开始，有以下规则：

    <img src="C:\Users\MHTzt\AppData\Roaming\Typora\typora-user-images\image-20220321170601503.png" alt="image-20220321170601503" style="zoom:50%;" /><img src="C:\Users\MHTzt\AppData\Roaming\Typora\typora-user-images\image-20220321170610353.png" alt="image-20220321170610353" style="zoom:50%;" />

    则之前例子的有穷自动机为：

    <img src="C:\Users\MHTzt\AppData\Roaming\Typora\typora-user-images\image-20220321170635598.png" alt="image-20220321170635598" style="zoom:50%;" />
    
    **注：**这里要记住，NFA的任务是用于了解分析的状态，而不是之前的自动机那样被设计为完全识别串。
    
    对应的DFA：
    
    <img src="C:\Users\MHTzt\AppData\Roaming\Typora\typora-user-images\image-20220402172154960.png" alt="image-20220402172154960" style="zoom:50%;" />
    
  - LR(0)文法分析表

    考虑文法：A->(A)|a，它的DFA为：

    <img src="C:\Users\MHTzt\AppData\Roaming\Typora\typora-user-images\image-20220402173554481.png" alt="image-20220402173554481" style="zoom:50%;" />

    则它的文法分析表为：

    <img src="C:\Users\MHTzt\AppData\Roaming\Typora\typora-user-images\image-20220402173617115.png" alt="image-20220402173617115" style="zoom:50%;" />

    状态对应DFA中的**序号**，面对每个**状态**，遇到不同的**输入**，应该使用什么**规则**做什么**动作**，然后**跳到状态**几。

- LR(0)分析算法：

  1. 移进：若状态S存在A->α.Xβ，其中X是一个终结符，则动作就是将当前的输入记号移入栈中（一位内是LR0，所以没有先行符），若是X，则变为A->αX.β，若不是X，则申明一个错误。
  2. 规约：若状态S存在A->α，如果输入为空，则规约，如果不为空，则出现错误。（因为如果不为空，那么可以规约，可以移进，产生歧义）。

  如果以上规则都是无歧义的，则文法就是LR(0)文法。这就是第2点介绍的，如果这个状态包含了A->α的规约，就不能包含其他项目了，否则就会有歧义。

- SLR(1)分析算法：

  SLR(1): simple LR(1)，简单LR1分析，即通过使用输入串中下一个记号来指导动作。同时就需要Follow集合了。

  定义：

  1. 若状态S存在A->α.Xβ，X是非终结符，且是下一个输入的记号，则将其替换为A->αX.β。
  2. 若状态S存在完整项规约A->α，若下一个输入记号属于Follow(A)，则进行替换。
  3. 若下一个输入记号都不属于以上情况，则报告错误。

  若上述的SLR(1)分析规则并不导致二义性，则文法为SLR(1)文法。

  同时，如果满足以下两个条件，也可以判断SLR(1)文法：

  1. 对于在S中的任何项目A->α.Xβ，当X是一个终结符，且X在Follow(B)中时，S中没有完整的项目B->γ.。
  2. 对于在S中的任何两个完整项目A->α.和B->β.，Follow(A)∩Follow(B)为空。

  - SLR(1)分析表：

    <img src="C:\Users\MHTzt\AppData\Roaming\Typora\typora-user-images\image-20220402174549052.png" alt="image-20220402174549052" style="zoom:50%;" />

    和LR(0)差不多。

- 分析冲突，消除二义性

  SLR(1)分析中以及所有的移进-归约分析方法中的分析冲突都可以分为两类：移进-归约冲突和归约-归约冲突。在移进-归约冲突中，我们总是选取移进而不是归约，这样就解决了移进-归约冲突，但是归约-归约冲突就复杂一些，只能指出一个错误。

- SLR(k)文法

  和LL(k)-LL(1)之间的关系一样，指向前分析k个先行词。

- LR(1)项的有穷自动机：

  LR(1)项是由LR(0)项和一个先行记号组成的。利用中括号将LR(1)项写作：$[A\rightarrow \alpha .\beta,a]$.

  其中A->α.β是一个LR(0)项，a是先行记号。

- LR(1)分析算法：

  令s为当前状态（在栈顶）：

  1. 若s包含了[A->α.Xβ, a]的任意LR(1)项目，其中X是一个终结符且是输入串中的下一个记号，则动作就是将输入记号移进栈中，且被压入到栈中的新状态是包含了LR(1)项目[A->αX.β, a]的状态。
  2. 若状态s包含了完整的LR(1)项目[A->α., a]，且输入串中的下一个记号是a，则动作就是按A->α归约。
  3. 若下一个输入记号都不是以上情况，则申明错误。

  若以上规则不引起歧义，则该文法是LR(1)文法。同样地，如果满足以下两个条件，则也属于LR(1)文法：

  1. 对于在s中的任何项目[A->α.Xβ, a]，且X是一个终结符，则在s中没有格式[B->β., X]的项目。（否则就有一个移进-归约冲突）
  2. 在s中没有格式[A->α., a]和[B->β., a]的两个项目（否则就有一个归约-归约冲突）

- LR(1)分析表：

  对于 A->(A)|a，其DFA为：

  <img src="C:\Users\MHTzt\AppData\Roaming\Typora\typora-user-images\image-20220402185442998.png" alt="image-20220402185442998" style="zoom:50%;" />

  则其分析表为：

  <img src="C:\Users\MHTzt\AppData\Roaming\Typora\typora-user-images\image-20220402185510016.png" alt="image-20220402185510016" style="zoom:50%;" />

- LALR(1)分析：

  LALR(1)分析就是LR(1)分析中，把那些规则相同，先行符不同的项目组成一个集合。相当于压缩了LR(1)的DFA

  LALR(1)项目的压缩了的DFA的分析算法和上一节描述的一般的LR(1)分析算法相同。
  
  如果一个规则符合LALR(1)文法，则它的LALR(1) parsing table没有reduce-reduce conflict。反之亦然。
  
  请注意，如果一个规则符合LR(1)文法，则它没有shift-reduce conflict。

### Ch6 语义分析

- 属性和属性文法

  属性有以下几类：

  - 变量的数据类型
  - 表达式的值
  - 存储器中变量的位置
  - 程序的目标代码
  - 数的有效位数

  在执行之前联编的属性称为静态属性，只在执行期间联编的属性是动态属性。

#### 属性文法：

一般地，将属性文法写成表格形式：

![image-20220611180056657](C:\Users\MHTzt\AppData\Roaming\Typora\typora-user-images\image-20220611180056657.png)

val的文法方向是从右到左赋值。考虑如下表达式文法：<img src="C:\Users\MHTzt\AppData\Roaming\Typora\typora-user-images\image-20220402193053511.png" alt="image-20220402193053511" style="zoom:50%;" />

val的属性文法为：<img src="C:\Users\MHTzt\AppData\Roaming\Typora\typora-user-images\image-20220402193119878.png" alt="image-20220402193119878" style="zoom:50%;" />

type的文法方式是从左到右赋值。考虑如下表达式文法：<img src="C:\Users\MHTzt\AppData\Roaming\Typora\typora-user-images\image-20220402195703002.png" alt="image-20220402195703002" style="zoom:50%;" />

type的属性文法为：<img src="C:\Users\MHTzt\AppData\Roaming\Typora\typora-user-images\image-20220402195736168.png" alt="image-20220402195736168" style="zoom:50%;" />

还可以添加if…then…else…扩充语义规则。

#### 属性计算

- 合成和继承属性

  **定义：**一个属性是**合成**的，如果在语法树中它所有的相关都从子节点指向父节点（如val）。
  
  如果一个属性文法中所有的属性都是合成的，就是S属性文法（S-attributed grammar）。
  
  合成可以使用**后序遍历**来进行属性计算。
  
  **定义：**一个属性如果不是合成的，那么它是 **继承**的。
  
  继承有从父节点指向子节点，或者兄弟节点互指。
  
  继承可以使用 **中序遍历+前序遍历** 来进行属性计算。
  
- 语法分析时的属性计算

  **定义：**属性$a_1,…,a_k$的一个属性文法是L-属性(L-attributed)，如果对每个继承属性X.a，在$X_i$处$a_j$的值只依赖在文法规则中$X_i$左边出现的符号X的属性。

  做为一个特例：S-属性文法是L-属性文法。

  **定理：**给定一个属性文法，通过适当地修改文法，而无需改变文法的语言，所有的继承属性可以改变成合成属性。

  但事实上，状态理论并不像看起来那么有用。这样的改变往往会使文法和语义规则更加复杂和难以理解。

#### 符号表

符号表是编译器中的主要继承属性。符号表主要的操作有插入、查找和删除。

- 符号表结构

  线性表、各种搜索树（二叉、AVL、B-tree）以及hash表。

  对于hash表解决冲突有分离链表和开放寻址。

  <img src="C:\Users\MHTzt\AppData\Roaming\Typora\typora-user-images\image-20220613154919583.png" alt="image-20220613154919583" style="zoom:50%;" />

  一种通用的方式是总插入在表的开始。即size出现比j晚，插入在j前。

- 作用域规则

  <img src="C:\Users\MHTzt\AppData\Roaming\Typora\typora-user-images\image-20220613161403886.png" alt="image-20220613161403886" style="zoom:50%;" /><img src="C:\Users\MHTzt\AppData\Roaming\Typora\typora-user-images\image-20220613161419631.png" alt="image-20220613161419631" style="zoom:50%;" />

  对于不同作用域分配不同区域的符号表。

### Ch7 运行时环境

像0或1这样较小的编译时常量通常由编译程序直接插入到代码中且不为其分配任何数据空间。

大型的整数值、浮点值，特别是串文字分配到全局/静态区域中的存储器，在启动是仅保存一次。

一种一般的运行时存储器组织如下所示：<img src="C:\Users\MHTzt\AppData\Roaming\Typora\typora-user-images\image-20220614165451946.png" alt="image-20220614165451946" style="zoom:67%;" />

存储器分配中的一个重要单元是过程活动记录(Procedure activation record)，它包含了为其局部数据分配的存储器。它包括以下部分：<img src="C:\Users\MHTzt\AppData\Roaming\Typora\typora-user-images\image-20220614165610342.png" alt="image-20220614165610342" style="zoom:50%;" />

根据语言的不同，将活动记录分配在静态区域（FORTRAN77）、栈区（C、Pascal）、堆区（LISP）。

处理器还具有一些特殊用途的寄存器，如程序计数器pc、栈指针sp、只想当前活动记录的框架指针fp。

#### 完全静态环境

完全静态环境中，不仅全局变量，所有变量都是静态分配。我们可以通过固定的地址直接访问所有变量。<img src="C:\Users\MHTzt\AppData\Roaming\Typora\typora-user-images\image-20220614170030043.png" alt="image-20220614170030043" style="zoom:50%;" />

#### 基于栈的运行时环境

对于求gcd的程序，当我们输入15，10来求gcd(15,10)的值时，环境如下：

<img src="C:\Users\MHTzt\AppData\Roaming\Typora\typora-user-images\image-20220614170340299.png" alt="image-20220614170340299" style="zoom:50%;" />

我们用sp指向当前栈顶，fp指向当前活动。这两个指针通常保存在寄存器中。先前活动的fp回保存在它调用的函数的活动记录中，形成控制链（control link；也称动态链，dynamic link）。

**带有局部过程的基于栈的环境**：对于Pascal之类的语言，存在局部函数：

<img src="C:\Users\MHTzt\AppData\Roaming\Typora\typora-user-images\image-20220614201803279.png" alt="image-20220614201803279" style="zoom: 67%;" />

我们使用access link来指向外层函数的活动记录。全局函数没有access link。如果过程p在源码直接嵌套在过程q中，那么p的任何活动中的access link都一定指向q最近的活动。上面程序的环境如下：

<img src="C:\Users\MHTzt\AppData\Roaming\Typora\typora-user-images\image-20220614202026876.png" alt="image-20220614202026876" style="zoom: 67%;" />

而如果被嵌套的程序不是并列的，而是逐层嵌套的，那么access link指向的还是它的上一层的活动记录。

**access link的维护：** 对于x一级嵌套y，y的access link就指向x的活动记录。对于x和y并列嵌套在z中，则y的access link指向x的access link的指向对象。如果x多级嵌套于y，则y需要多级access link指向x。

#### 完全动态环境

完全动态环境需要考虑垃圾回收，有三种常见的垃圾回收机制：

- mark and sweep，周期性地，或是在 malloc 失败时，从 static & local 出发进行标记，标出所有可达的内存块。剩余的块就是无法被触及的内存，就可以回收掉了。
  - 在回收之后，还可以使用 memory compaction 来将所有分配的空间移到堆的末尾，从而留出连续的空闲空间。
- stop and copy / two space，将存储区分为两部分，每次只使用一部分，存储区满时从 static & local 出发将所有可达的内存块复制到另一部分中，这样不需要两遍遍历，也自然进行了 memory compaction。

- generational garbage collection，将存在时间足够长的被分配的对象复制到永久空间中，并在随后的存储回收时不再重新分配。这就意味着垃圾回收程序在更新的存储分配时只需要搜索存储器中的很小的一个部分。

#### 参数传递机制

- 值传递 Pass by value

  C语言中的参数传递方式。在C中即使我们通过传入指针变量，本质上也是将实参中指针变量的值复制到形参的相应变量中去。

- 引用传递 Pass by reference

  传递变量的引用，即传递其在存储空间中的位置。在函数中所做的一切更改都会作用于这个变量本身。

- 值传递结果 Pass by Value-result

  将实参从左到右逐个复制到形参中，在函数运行结束后再逐个将其复制回原来的位置。

- 名字传递 Pass by name

  即直到函数真正使用了某个参数时才对其赋值，因此也称为延迟赋值。等价的做法是将函数在调用的原位进行展开。

<img src="C:\Users\MHTzt\AppData\Roaming\Typora\typora-user-images\image-20220614234504403.png" alt="image-20220614234504403" style="zoom: 67%;" />

对于以上运行代码

值传递：1 1。i=0,所以调用的是p(a[0],a[0])，但是这不会影响实参。

引用传递：3 1。i=0所以调用的是p(a[0],a[0])，而这个会改变实参。

值结果传递：2 1。i=0所以调用的是p(a[0],a[0])，然后先将x=2赋值给a[0]，再把y=2赋值给a[0]，所以a[0]是2。

名称传递：2 2。i=0所以先处理a[0]，然后将x=2赋值给a[0]，然后i=1，再处理a[1]，然后将y=2赋值给a[1]。

### Ch8 代码生成

AST是IR的一种，但是要生成代码需要先将它线性化，变成一种更类似目标代码的中间表示。我们将其称为 **中间代码**。**三地址码 three-address code** 和**P-代码 P-code**属于中间代码。

#### 三地址码

对于表达式：`2*a+(b-3)`，其三地址码为：`t1=2*a t2=b-3 t3=t1+t2`。

其中t1,t2,t3是临时变量名。

下图中左边是程序代码，右边是三地址码：

<img src="C:\Users\MHTzt\AppData\Roaming\Typora\typora-user-images\image-20220615161028581.png" alt="image-20220615161028581" style="zoom: 67%;" />

> 如果生成中间代码只是编译中的一个步骤，我们可以不必打印成文本，而是可以直接在程序中用一定的数据结构记录这些中间代码。

对于三地址码，保存其信息需要3个地址（两个操作符地址和一个目标地址）和1个操作符，因此称为 **四元式 quadruple**，例如上面的三地址码用四元式表示为：

<img src="C:\Users\MHTzt\AppData\Roaming\Typora\typora-user-images\image-20220615161531004.png" alt="image-20220615161531004" style="zoom:67%;" />

我们可以将三地址中的那个目标地址默认为行号表示的一个临时变量，就可以将四元式转换为 **三元式 triple**，如：

<img src="C:\Users\MHTzt\AppData\Roaming\Typora\typora-user-images\image-20220615161743222.png" alt="image-20220615161743222" style="zoom:67%;" />

为了执行一些地址计算和指针引用，引入了取址和取值操作符&和*。为了方便数组访问，引入了[]运算。

函数调用如下：

<img src="C:\Users\MHTzt\AppData\Roaming\Typora\typora-user-images\image-20220615162130076.png" alt="image-20220615162130076" style="zoom:67%;" />

#### P-Code

P-Code的运行依赖一个临时的栈。例如，`2*a+(b-3)`的P-Code如下：

<img src="C:\Users\MHTzt\AppData\Roaming\Typora\typora-user-images\image-20220615162324018.png" alt="image-20220615162324018" style="zoom:67%;" />

mpi,sbi,adi这些操作都是从栈上弹出两个操作数，进行计算，再压到栈顶。

对于赋值语句`x:=y+1`，P-Code为：

<img src="C:\Users\MHTzt\AppData\Roaming\Typora\typora-user-images\image-20220615162509241.png" alt="image-20220615162509241" style="zoom: 67%;" />

sto表示将栈顶元素弹出写出目前load的地址。

<img src="C:\Users\MHTzt\AppData\Roaming\Typora\typora-user-images\image-20220615162753062.png" alt="image-20220615162753062" style="zoom:67%;" />

对于控制语句： `if(E) S1 else S2`:

```assembly
<判断E>
fjp L1
<S1 code>
ujp L2
lab L1
<S2 code>
lab S2
```

`while(E) S`:

```assembly
lab L1
<判断E>
fjp L2
<S code>
ujp L1
lab L2
```

函数调用：

<img src="C:\Users\MHTzt\AppData\Roaming\Typora\typora-user-images\image-20220615163415580.png" alt="image-20220615163415580" style="zoom:67%;" />

P-Code比三地址码更接近实际的机器码。
