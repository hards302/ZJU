# Safe Fruit
## 要求
### 输入说明
* 第一行： N(# of tips), M(# of fruits in basket), M,N <= 100
* N 行 不能一起吃的水果对
* M 行 水果名称(用一个3位整数表示，即0<=id<=999) 和对应价格 (0<=p<=1000)
### 输出要求
注意：可能存在多个解，但我们只输出有最大水果种数的 safe fruits 集合；如果仍然存在冲突，输出总价值最小的；
* safe fruits 的最大数量
* 列出所有的 safe fruit，依照 id 升序排列 (id间只有一个空格，末尾没有空格)
* 上述水果的总价格

### 测试思路
* 测试正确性
* 生成多样的测试样例：
    * 图的结点数
    * 图的连通性
    * 
* 本问题有三个剪枝：
    * 分别讨论三个剪枝的影响
* 设置对照实验
    * 三个剪枝都有
    * 没有 A
    * 没有 B
    * 没有 C
    * 对照组()
#### 测试任务
* 产生样例的程序: 输入结点数，稠密度，返回符合题目要求的随机样例
* 记录时间，比较结果的差异 

### 总体任务
* 测试
    * 产生样例
    * 做实验
* 报告
* PPT


### 最大团算法介绍
1. 剪枝1：常用的指定顺序, 即枚举第i个顶后, 以后再枚举时枝考虑下标比大它的, 避免重复。
2. 剪枝2
    * 自己开始从前往后的枚举顶点, TLE两次. 后来从后往前枚举顶点，发现可以利用顶点之间的承袭性.我用num[i] 记录的可选顶点集合为 V[i, i+1, ... , n] 中的最大团数目， 目标是求num[1].
    * 分析易知, num[i] = num[i+1] 或者 num[i+1]+1   (num[1...n] 具有非降的单调性,从后往前求)由这个式子以及num[]信息的记录，使得我们可以增加两处剪枝:

        1. 上/下剪枝：假设当前枚举的是顶点x, 它的第一个邻接顶是i (标号一定比x大，即num[i]已经求出) 我们可以知道， 若 1 + num[i] <= best, 那么是没没要往下枚举这个顶点x了，因为包含它的团是不可能超过我们目前的最优值的。
        2. 立即返回剪枝: 由于num[i]最大可能为num[i+1]+1, 所以在枚举顶点i时，只要一更新best，可知此时的num[i]就为num[i+1]+1了，不需要再去尝试找其他的方案了，所以应立即返回.

### 测试代码介绍
* testcode文件夹中包含safefruit代码，在输出开始时会输出边数和点数，用来显示稠密度与图的规模。之后的时间测试也可以在这里测试。
* small文件输出规模较小的图，normal输出正常的图，dense输出稠密图，sparse输出稀疏图，所有的输出保存在同目录的test.txt文件夹。